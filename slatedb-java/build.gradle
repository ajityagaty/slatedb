// This build creates a Java library that contains generated FFI bindings and bundled
// native SlateDB binaries. jextract reads ../slatedb-c/include/slatedb.h and generates
// Java sources for the C API, using an automatically derived whitelist so generated
// bindings stay aligned with the header.
//
// After generation, `patchJextractNativeLoader` rewrites the generated loader call
// to use io.slatedb.NativeLibraryLoader.loadFromClasspath() instead of directly
// calling System.loadLibrary(...).
//
// Native binaries are built from the Rust crate `slatedb-c`. The build can target the
// host platform, all platforms, or a comma-separated platform list via
// -Pslatedb.native.targets. It registers one native build task per selected platform,
// then `prepareNativeLibraries` validates and stages the built artifacts under
// build/generated/resources/slatedb-native/native/<platform-id>/. These build
// artifacts are then included in the final JAR.
//
// The main source set includes both the jextract output and these staged native files.
// Task wiring ensures compileJava depends on patchJextractNativeLoader and
// processResources depends on prepareNativeLibraries, so `build` and `test` always run
// with patched bindings and packaged native libraries available from the classpath.

plugins {
    id 'java-library'
    id 'de.infolektuell.jextract' version '1.2.0'
}

// ==============================================================================
// jextract configuration to generate Java bindings for the slatedb C library.
// ==============================================================================
//
// Use jextract to generate Java bindings for the slatedb C library, filtering
// to include only the relevant functions, constants, structs, and typedefs defined
// in slatedb.h.
//
// See:
// - https://infolektuell.github.io/gradle-jextract/filtering/
// - https://github.com/openjdk/jextract/blob/master/doc/GUIDE.md#filtering
def slatedbHeader = layout.projectDirectory.file('../slatedb-c/include/slatedb.h')
def slatedbHeaderText = slatedbHeader.asFile.getText('UTF-8')
// Captures top-level `slatedb_*` function names (excluding typedefs/comments), regardless of return type.
def slatedbIncludeFunctions = ((slatedbHeaderText =~ /(?m)^(?!\s*(?:\/\/|\/\*|\*))\s*(?!typedef\b).*?\b(slatedb_[A-Za-z0-9_]+)\s*\(/).collect { it[1] } as Set).toList().sort()
// Captures public `SLATEDB_*` preprocessor constants.
def slatedbIncludeConstants = ((slatedbHeaderText =~ /(?m)^\s*#define\s+(SLATEDB_[A-Z0-9_]+)\b/).collect { it[1] } as Set).toList().sort()
// Captures named struct types declared as `typedef struct slatedb_* { ... }`.
def slatedbIncludeStructs = ((slatedbHeaderText =~ /(?m)^\s*typedef\s+struct\s+(slatedb_[A-Za-z0-9_]+)\s*\{/).collect { it[1] } as Set).toList().sort()
// Captures `slatedb_*` typedef names, including function-pointer typedef aliases.
def slatedbIncludeTypedefs = ((slatedbHeaderText =~ /(?ms)^\s*typedef\b.*?(?:\(\*\s*)?(slatedb_[A-Za-z0-9_]+)\s*\)?\s*;/).collect { it[1] } as Set).toList().sort()

def slatedbJextractLibrary = jextract.libraries.create('slatedb') {
    header = slatedbHeader
    includes = [layout.projectDirectory.dir('../slatedb-c/include')]
    targetPackage = 'io.slatedb.ffi'
    headerClassName = 'Native'
    libraries = ['slatedb_c']
    useSystemLoadLibrary = true
    whitelist {
        functions = slatedbIncludeFunctions
        constants = slatedbIncludeConstants
        structs = slatedbIncludeStructs
        typedefs = slatedbIncludeTypedefs
    }
}

// ==============================================================================
// Standard Java library configuration below.
// ==============================================================================

group = 'io.slatedb'
version = '0.1.0-SNAPSHOT'

def minimumJava = 24
def currentJava = JavaVersion.current()
def toolchainVersion = currentJava.isCompatibleWith(JavaVersion.toVersion(minimumJava))
    ? Integer.parseInt(currentJava.majorVersion)
    : minimumJava

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(toolchainVersion)
    }
    sourceCompatibility = JavaVersion.toVersion(minimumJava)
    targetCompatibility = JavaVersion.toVersion(minimumJava)
}

tasks.withType(JavaCompile).configureEach {
    options.release = minimumJava
}

repositories {
    mavenCentral()
}

// ==============================================================================
// Bundle native libraries from slatedb-c as resources in the JAR
// ==============================================================================

def repoRoot = layout.projectDirectory.dir('..').asFile.absoluteFile
def nativePlatforms = [
    [id: 'linux-x86_64', rustTarget: 'x86_64-unknown-linux-gnu', libraryFile: 'libslatedb_c.so'],
    [id: 'linux-aarch64', rustTarget: 'aarch64-unknown-linux-gnu', libraryFile: 'libslatedb_c.so'],
    [id: 'macos-x86_64', rustTarget: 'x86_64-apple-darwin', libraryFile: 'libslatedb_c.dylib'],
    [id: 'macos-aarch64', rustTarget: 'aarch64-apple-darwin', libraryFile: 'libslatedb_c.dylib'],
    [id: 'windows-x86_64', rustTarget: 'x86_64-pc-windows-msvc', libraryFile: 'slatedb_c.dll'],
    [id: 'windows-aarch64', rustTarget: 'aarch64-pc-windows-msvc', libraryFile: 'slatedb_c.dll']
]
def nativePlatformsById = nativePlatforms.collectEntries { platform -> [(platform.id): platform] }

// Helper functions to normalize OS and architecture names for host platform detection.
def normalizeOs = { String osName ->
    String normalized = osName.toLowerCase(Locale.ROOT)
    if (normalized.contains('win')) {
        return 'windows'
    }
    if (normalized.contains('mac') || normalized.contains('darwin')) {
        return 'macos'
    }
    if (normalized.contains('linux')) {
        return 'linux'
    }
    return normalized
}

def normalizeArch = { String archName ->
    String normalized = archName.toLowerCase(Locale.ROOT)
    if (normalized in ['amd64', 'x86_64', 'x64']) {
        return 'x86_64'
    }
    if (normalized in ['aarch64', 'arm64']) {
        return 'aarch64'
    }
    return normalized
}

def hostPlatformId = "${normalizeOs(System.getProperty('os.name', ''))}-${normalizeArch(System.getProperty('os.arch', ''))}"

// Determine which native platforms to build based on the 'slatedb.native.targets' property. Supported values:
// - 'host' (default): Build only for the current host platform.
// - 'all': Build for all supported platforms.
// - Comma-separated list of platform IDs (e.g. 'linux-x86_64,windows-x86_64').
def nativeTargetSelection = (findProperty('slatedb.native.targets') ?: 'host').toString().trim()
def selectedNativePlatforms
if (nativeTargetSelection.equalsIgnoreCase('all')) {
    selectedNativePlatforms = nativePlatforms
} else if (nativeTargetSelection.equalsIgnoreCase('host')) {
    def hostPlatform = nativePlatformsById[hostPlatformId]
    if (hostPlatform == null) {
        throw new GradleException(
            "Unsupported host platform '${hostPlatformId}'. " +
                "Set -Pslatedb.native.targets=<comma-separated platform IDs>. " +
                "Supported IDs: ${nativePlatforms*.id.join(', ')}"
        )
    }
    selectedNativePlatforms = [hostPlatform]
} else {
    def selectedIds = nativeTargetSelection
        .split(',')
        .collect { it.trim() }
        .findAll { !it.isEmpty() }
    if (selectedIds.isEmpty()) {
        throw new GradleException(
            "Invalid -Pslatedb.native.targets value '${nativeTargetSelection}'. " +
                "Use 'host', 'all', or a comma-separated list of platform IDs."
        )
    }
    def unknownIds = selectedIds.findAll { !nativePlatformsById.containsKey(it) }
    if (!unknownIds.isEmpty()) {
        throw new GradleException(
            "Unknown native platform IDs: ${unknownIds.join(', ')}. " +
                "Supported IDs: ${nativePlatforms*.id.join(', ')}"
        )
    }
    selectedNativePlatforms = selectedIds.collect { nativePlatformsById[it] }
}

// Define tasks to build the native libraries for the selected platforms using Cargo. Each task is
// named like 'buildNativeLibLinuxX86_64' based on the platform ID.
def toTaskSuffix = { String value ->
    value.split(/[-_]/).collect { it.capitalize() }.join('')
}

def nativeResourceStagingDir = layout.buildDirectory.dir('generated/resources/slatedb-native')
def selectedNativeBuildTasks = selectedNativePlatforms.collect { platform ->
    tasks.register("buildNativeLib${toTaskSuffix(platform.id)}", Exec) {
        group = 'build'
        description = "Build slatedb-c native library for ${platform.id}"
        workingDir repoRoot
        commandLine 'cargo', 'build', '-p', 'slatedb-c', '--release', '--target', platform.rustTarget
    }
}

// Task to prepare native libraries by copying the built artifacts from the Cargo target directory
// into the resources staging directory. This task depends on the individual platform build tasks
// constructed in selectedNativeBuildTasks.
tasks.register('prepareNativeLibraries') {
    group = 'build'
    description = "Build and stage SlateDB native libraries for ${selectedNativePlatforms*.id.join(', ')}."
    dependsOn selectedNativeBuildTasks
    outputs.dir(nativeResourceStagingDir)
    doLast {
        File outputDir = nativeResourceStagingDir.get().asFile
        project.delete(outputDir)
        selectedNativePlatforms.each { platform ->
            File sourceFile = new File(repoRoot, "target/${platform.rustTarget}/release/${platform.libraryFile}")
            if (!sourceFile.isFile()) {
                throw new GradleException(
                    "Native library for ${platform.id} is missing at ${sourceFile}. " +
                        "Ensure the Rust target '${platform.rustTarget}' is installed and buildable."
                )
            }
            project.copy {
                from sourceFile
                into new File(outputDir, "native/${platform.id}")
            }
        }
    }
}

// Patch the generated jextract Native.java to replace the System.loadLibrary call with loading from the classpath.
// This is necessary because the generated jextract bindings will attempt to load the native library using
// System.loadLibrary, which won't work with our approach of bundling the native libraries as resources in the
// JAR. See the discussion in https://github.com/openjdk/jextract/pull/295 for more context on why jextract doesn't
// currently support customizing the native loading logic.
def generatedJextractNative = layout.buildDirectory.file('generated/sources/jextract/slatedb/io/slatedb/ffi/Native.java')
tasks.register('patchJextractNativeLoader') {
    dependsOn tasks.named('slatedbJextractGenerateBindings')
    inputs.file(generatedJextractNative)
    outputs.file(generatedJextractNative)
    doLast {
        File generatedNativeJava = generatedJextractNative.get().asFile
        if (!generatedNativeJava.isFile()) {
            throw new GradleException("Expected generated jextract file at ${generatedNativeJava}")
        }

        String sourceText = generatedNativeJava.getText('UTF-8')
        String originalLoaderCall = 'System.loadLibrary("slatedb_c");'
        String patchedLoaderCall = 'io.slatedb.NativeLibraryLoader.loadFromClasspath();'
        if (!sourceText.contains(originalLoaderCall) && !sourceText.contains(patchedLoaderCall)) {
            throw new GradleException(
                "Unable to patch jextract native loader call in ${generatedNativeJava}. " +
                    "Expected to find either '${originalLoaderCall}' or '${patchedLoaderCall}'."
            )
        }

        generatedNativeJava.setText(sourceText.replace(originalLoaderCall, patchedLoaderCall), 'UTF-8')
    }
}

// ==============================================================================
// Define basic library and task dependencies.
// ==============================================================================

sourceSets {
    main {
        jextract {
            libraries.add(slatedbJextractLibrary)
        }
        resources {
            srcDir(nativeResourceStagingDir)
        }
    }
}

dependencies {
    implementation 'org.jspecify:jspecify:1.0.0'
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.2'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher:1.10.2'
}

tasks.named('compileJava') {
    dependsOn tasks.named('patchJextractNativeLoader')
}

tasks.named('processResources') {
    dependsOn tasks.named('prepareNativeLibraries')
}

test {
    useJUnitPlatform()
    jvmArgs '--enable-native-access=ALL-UNNAMED'
}
